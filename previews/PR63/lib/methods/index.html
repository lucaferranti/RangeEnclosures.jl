<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Methods · RangeEnclosures.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/aligned.css" rel="stylesheet" type="text/css"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">RangeEnclosures.jl</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Library</span><ul><li><a class="tocitem" href="../types/">Types</a></li><li class="is-active"><a class="tocitem" href>Methods</a><ul class="internal"><li><a class="tocitem" href="#The-enclose-function-1"><span>The <code>enclose</code> function</span></a></li><li><a class="tocitem" href="#Utility-functions-1"><span>Utility functions</span></a></li><li><a class="tocitem" href="#Enclosure-methods-1"><span>Enclosure methods</span></a></li><li><a class="tocitem" href="#Specifics-to-interval-optimization-1"><span>Specifics to interval optimization</span></a></li><li><a class="tocitem" href="#Specifics-to-sum-of-squares-optimization-1"><span>Specifics to sum-of-squares optimization</span></a></li></ul></li></ul></li><li><a class="tocitem" href="../../about/">About</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Library</a></li><li class="is-active"><a href>Methods</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Methods</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaReach/RangeEnclosures.jl/blob/master/docs/src/lib/methods.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Methods-1"><a class="docs-heading-anchor" href="#Methods-1">Methods</a><a class="docs-heading-anchor-permalink" href="#Methods-1" title="Permalink"></a></h1><p>This section describes systems methods implemented in <code>RangeEnclosures.jl</code>.</p><ul><li><a href="#Methods-1">Methods</a></li><ul><li><a href="#The-enclose-function-1">The <code>enclose</code> function</a></li><li><a href="#Utility-functions-1">Utility functions</a></li><li><a href="#Enclosure-methods-1">Enclosure methods</a></li><li><a href="#Specifics-to-interval-optimization-1">Specifics to interval optimization</a></li><li><a href="#Specifics-to-sum-of-squares-optimization-1">Specifics to sum-of-squares optimization</a></li></ul></ul><h2 id="The-enclose-function-1"><a class="docs-heading-anchor" href="#The-enclose-function-1">The <code>enclose</code> function</a><a class="docs-heading-anchor-permalink" href="#The-enclose-function-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="RangeEnclosures.enclose" href="#RangeEnclosures.enclose"><code>RangeEnclosures.enclose</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">enclose(f::Function, dom::Interval_or_IntervalBox,
        solver::Symbol=:IntervalArithmetic; [kwargs]...)</code></pre><p>Return a range enclosure of a univariate or multivariate function on the given domain.</p><p><strong>Input</strong></p><ul><li><code>f</code>      – function</li><li><code>dom</code>    – hyperrectangular domain, either a unidimensional  <code>Interval</code> or             a multidimensional <code>IntervalBox</code></li><li><code>solver</code> – (optional, default: <code>IntervalArithmetic</code>) choose one among the             available solvers; see <code>RangeEnclosures.available_solvers</code> for the             full list</li><li><code>kwargs</code> – optional keyword arguments passed to the solver; for available             options see the documentation of each solver</li></ul><p><strong>Output</strong></p><p>An interval representing the range enclosure (minimum and maximum) of <code>f</code> over its domain <code>dom</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using RangeEnclosures

julia&gt; enclose(x -&gt; 1 - x^4 + x^5, 0..1) # use default solver
[0, 2]

julia&gt; enclose(x -&gt; 1 - x^4 + x^5, 0..1, :IntervalArithmetic)
[0, 2]

julia&gt; enclose(x -&gt; 1 - x^4 + x^5, 0..1, :TaylorModels, order=4)
[0.78125, 1.125]

julia&gt; enclose(x -&gt; 1 - x^4 + x^5, 0..1, :TaylorModels, order=10)
[0.8125, 1.09375]

julia&gt; enclose(x -&gt; 1 - x^4 + x^5, 0..1, :IntervalOptimisation)
[0.916034, 1.00213]</code></pre><p>You can also try other solvers such as <code>SumOfSquares</code> and <code>AffineArithmetic</code>.</p><p>A vector of solvers can be passed in the <code>solver</code> options. Then, the result is obtained by intersecting the range enclosure of each solver. In the previous example,</p><pre><code class="language-julia-repl">julia&gt; using RangeEnclosures

julia&gt; enclose(x -&gt; 1 - x^4 + x^5, 0..1, [:TaylorModels, :IntervalArithmetic])
[0.8125, 1.09375]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/RangeEnclosures.jl/blob/15bbfe9c7e0bba2161d170f1a00d06409fdedb16/src/enclose.jl#L1-L56">source</a></section></article><h2 id="Utility-functions-1"><a class="docs-heading-anchor" href="#Utility-functions-1">Utility functions</a><a class="docs-heading-anchor-permalink" href="#Utility-functions-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="RangeEnclosures.relative_precision" href="#RangeEnclosures.relative_precision"><code>RangeEnclosures.relative_precision</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">relative_precision(x::Interval{N}, xref::Interval{N}) where {N}</code></pre><p>Return the relative precision of an interval representing a range enclosure given a reference interval.</p><p><strong>Input</strong></p><ul><li><code>x</code>    – test interval</li><li><code>xref</code> – reference interval</li></ul><p><strong>Output</strong></p><p>An interval containing the left (resp. right) percentages that describe the relative precision of <code>x</code> with respect to the reference interval <code>xref</code>.</p><p><strong>Examples</strong></p><p>Suppose that the reference interval is <span>$[-1.2, 4.6]$</span>, and let <span>$[-1.25, 7.45]$</span> be the overapproximation of the reference interval obtained with some global optimisation method that returns a range enclosure. The relative precision is then:</p><pre><code class="language-julia-repl">julia&gt; using RangeEnclosures: relative_precision

julia&gt; xref = Interval(-1.2, 4.6)
[-1.2, 4.6]

julia&gt; x = Interval(-1.25, 7.45)
[-1.25, 7.45001]

julia&gt; relative_precision(x, xref)
[0.862068, 49.138]</code></pre><p>Notice how the percentage of relative error of the maximum is big, close to <span>$50%$</span>, while the approximation of the minimum is much smaller, close to <span>$1%$</span> of the reference value.</p><p><strong>Algorithm</strong></p><p>This function measures the relative precision of the result in a more informative way than taking the scalar overestimation because it evaluates the precision of the lower and the upper range bounds separately (cf. Eq. (20) in [1]).</p><p>[1] Althoff, Matthias, Dmitry Grebenyuk, and Niklas Kochdumper.    <em>Implementation of Taylor models in CORA 2018.</em>    Proc. of the 5th International Workshop on Applied Verification for    Continuous and Hybrid Systems. 2018.</p><p><strong>Notes</strong></p><p>It is assumed that the test, or paragon interval, is an overapproximation of the reference interval; otherwise the left or right percentages will be negative.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/RangeEnclosures.jl/blob/15bbfe9c7e0bba2161d170f1a00d06409fdedb16/src/enclose.jl#L133-L187">source</a></section></article><h2 id="Enclosure-methods-1"><a class="docs-heading-anchor" href="#Enclosure-methods-1">Enclosure methods</a><a class="docs-heading-anchor-permalink" href="#Enclosure-methods-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="RangeEnclosures.enclose_IntervalArithmetic" href="#RangeEnclosures.enclose_IntervalArithmetic"><code>RangeEnclosures.enclose_IntervalArithmetic</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">enclose_IntervalArithmetic(f::Function, dom::Interval_or_IntervalBox)</code></pre><p>Compute a range enclosure using interval arithmetic substitution.</p><p><strong>Input</strong></p><ul><li><code>f</code>   – function</li><li><code>dom</code> – hyperrectangular domain, either a unidimensional  <code>Interval</code> or          a multidimensional <code>IntervalBox</code></li></ul><p><strong>Output</strong></p><p>An interval representing the range enclosure (minimum and maximum) of <code>f</code> over its domain <code>dom</code>.</p><p><strong>Algorithm</strong></p><p>The result is obtained by substitution of <code>dom</code> on the function <code>f</code> and application of the rules of interval arithmetic.</p><p>We refer to the documentation and source code of <code>IntervalArithmetic</code> for details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/RangeEnclosures.jl/blob/15bbfe9c7e0bba2161d170f1a00d06409fdedb16/src/intervals.jl#L6-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RangeEnclosures.enclose_IntervalOptimisation" href="#RangeEnclosures.enclose_IntervalOptimisation"><code>RangeEnclosures.enclose_IntervalOptimisation</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">enclose_IntervalOptimisation(f::Function, dom::Interval_or_IntervalBox;
                             structure=HeapedVector, tol=1e-3)</code></pre><p>Compute a range enclosure using interval optimisation.</p><p><strong>Input</strong></p><ul><li><code>f</code>         – function</li><li><code>dom</code>       – hyperrectangular domain, either a unidimensional  <code>Interval</code> or                a multidimensional <code>IntervalBox</code></li><li><code>structure</code> – (optional, default: <code>HeapedVector</code>) the way in which vector elements                are kept arranged; possible options are <code>HeapedVector</code> and <code>SortedVector</code></li><li><code>tol</code>       – tolerance to which the optima are computed</li></ul><p><strong>Output</strong></p><p>An interval representing the range enclosure (minimum and maximum) of <code>f</code> over its domain <code>dom</code>.</p><p><strong>Algorithm</strong></p><p>The solver finds the global minimum of the function <code>f</code> over the <code>Interval</code> or <code>IntervalBox</code> <code>dom</code> using the Moore-Skelboe algorithm. The method actually returns an <em>interval</em> containing the global minimum (resp. an <em>interval</em> containing the global maximum), as well as a list of boxes containing the minimisers (resp. maximisers); they can be obtained calling <a href="#RangeEnclosures.range_and_optimisers"><code>range_and_optimisers</code></a>.</p><p>This function conservatively chooses the infimum (resp. supremum) over each interval.</p><p>We refer to the documentation and source code of <code>IntervalOptimisation</code> for details on the implemented methods.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/RangeEnclosures.jl/blob/15bbfe9c7e0bba2161d170f1a00d06409fdedb16/src/intervals.jl#L90-L122">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RangeEnclosures.enclose_TaylorModels" href="#RangeEnclosures.enclose_TaylorModels"><code>RangeEnclosures.enclose_TaylorModels</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">enclose_TaylorModels(f::Function, dom::Interval_or_IntervalBox;
                     order::Int=10, normalize::Bool=true)</code></pre><p>Compute a range enclosure using Taylor Models substitution.</p><p><strong>Input</strong></p><ul><li><code>f</code>         – function</li><li><code>dom</code>       – hyperrectangular domain, either a unidimensional  <code>Interval</code> or                a multidimensional <code>IntervalBox</code></li><li><code>order</code>     – (optional, default: <code>10</code>) order of the taylor model used to compute                an enclosure of <code>f</code> over <code>dom</code></li><li><code>normalize</code> – (optional, default: <code>true</code>) if <code>true</code>, normalize the taylor model                on the unit symmetric box around the origin</li></ul><p><strong>Output</strong></p><p>An interval representing the range enclosure (minimum and maximum) of <code>f</code> over its domain <code>dom</code>.</p><p><strong>Algorithm</strong></p><p>The result is obtained by an evaluation of the function over Taylor model variables after recentering in the given domain and (optionally) normalizing in the symmetric <span>$[-1..1]^n$</span> domain.</p><p>We refer to the documentation and source code of <code>TaylorModels</code> for details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/RangeEnclosures.jl/blob/15bbfe9c7e0bba2161d170f1a00d06409fdedb16/src/taylormodels.jl#L9-L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RangeEnclosures.enclose_SumOfSquares" href="#RangeEnclosures.enclose_SumOfSquares"><code>RangeEnclosures.enclose_SumOfSquares</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">enclose_SumOfSquares(f::Function, dom::Interval_or_IntervalBox,
                     order::Int=5, backend=SDPA.Optimizer; kwargs...)</code></pre><p>Compute a range enclosure using sum-of-squares optimization.</p><p><strong>Input</strong></p><ul><li><code>f</code>       – function</li><li><code>dom</code>     – hyperrectangular domain, either a unidimensional <code>Interval</code> or              a multidimensional <code>IntervalBox</code></li><li><code>order</code>   – (optional, default: <code>5</code>) maximum degree of the SDP relaxation</li><li><code>backend</code> – (optional, default: <code>SDPA.Optimizer</code>) the optimization backend              (aka JuMP solver)</li><li><code>kwargs</code>  – additional keyword arguments</li></ul><p><strong>Output</strong></p><p>An interval representing the range enclosure (minimum and maximum) of <code>f</code> over its domain <code>dom</code>.</p><p><strong>Algorithm</strong></p><p>The range enclosure is computed using polynomial optimization methods. We refer to the documentation and examples of <code>SumOfSquares.jl</code> for details.</p><p><strong>Notes</strong></p><p>Use the <code>backend</code> keyword argument to pass an SDP solver backend of your choice; additional arguments to the solver can be passed in <code>kwargs</code>.</p><p>For instance, to use <code>SDPA</code> (default choice), use it as:</p><pre><code class="language-julia">julia&gt; backend = SDPA.Optimizer

julia&gt; enclose_SumOfSquares(f, dom, order, backend=backend)
...</code></pre><p>To use <code>MOSEK</code> in non-verbose mode, let</p><pre><code class="language-julia">julia&gt; using MosekTools

julia&gt; backend = MosekTools.Mosek.Optimizer;

julia&gt; enclose_SumOfSquares(f, dom, order, backend=backend, QUIET=true)
...</code></pre><p>To get the runtime, use <code>MOI.get(model, MOI.SolveTime())</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/RangeEnclosures.jl/blob/15bbfe9c7e0bba2161d170f1a00d06409fdedb16/src/sdp.jl#L40-L92">source</a></section></article><h2 id="Specifics-to-interval-optimization-1"><a class="docs-heading-anchor" href="#Specifics-to-interval-optimization-1">Specifics to interval optimization</a><a class="docs-heading-anchor-permalink" href="#Specifics-to-interval-optimization-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="RangeEnclosures.range_and_optimisers" href="#RangeEnclosures.range_and_optimisers"><code>RangeEnclosures.range_and_optimisers</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">range_and_optimisers(f::Function, dom::Interval_or_IntervalBox;
                     structure=HeapedVector, tol=1e-3)</code></pre><p>Return an interval that contains the global minimum (resp. an interval that contains the global maximum) of a univariate or multivariate function <code>f</code>, as well as a list of boxes containing the minimisers (resp. minimisers).</p><p><strong>Input</strong></p><ul><li><code>f</code>         – function</li><li><code>dom</code>       – hyperrectangular domain, either a unidimensional  <code>Interval</code> or                a multidimensional <code>IntervalBox</code></li><li><code>structure</code> – (optional, default: <code>HeapedVector</code>) the way in which vector elements                are kept arranged; possible options are <code>HeapedVector</code> and <code>SortedVector</code></li><li><code>tol</code>       – tolerance to which the optima are computed</li></ul><p><strong>Output</strong></p><p>The 4-tuple <code>(global_min, minimisers, global_max, maximisers)</code>, where:</p><ul><li><code>global_min</code>: interval that is guaranteed to contain the global minimum of <code>f</code>               over <code>dom</code></li><li><code>minimisers</code>: list of boxes containing the minimisers of <code>f</code> over <code>dom</code></li><li><code>global_max</code>: interval that is guaranteed to contain the global maximum of <code>f</code>               over <code>dom</code></li><li><code>maximisers</code>: list of boxes containing the maximisers of <code>f</code> over <code>dom</code></li></ul><p><strong>Algorithm</strong></p><p>The solver finds the global minimum of the function <code>f</code> over the <code>Interval</code> or <code>IntervalBox</code> <code>dom</code> using the Moore-Skelboe algorithm.</p><p>We refer to the documentation and source code of <code>IntervalOptimisation</code> for details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/RangeEnclosures.jl/blob/15bbfe9c7e0bba2161d170f1a00d06409fdedb16/src/intervals.jl#L38-L72">source</a></section></article><h2 id="Specifics-to-sum-of-squares-optimization-1"><a class="docs-heading-anchor" href="#Specifics-to-sum-of-squares-optimization-1">Specifics to sum-of-squares optimization</a><a class="docs-heading-anchor-permalink" href="#Specifics-to-sum-of-squares-optimization-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="RangeEnclosures.new_sos" href="#RangeEnclosures.new_sos"><code>RangeEnclosures.new_sos</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">new_sos(backend; kwargs...)</code></pre><p>Return a new (empty) sum-of-squares optimization problem for the given backend.</p><p><strong>Input</strong></p><ul><li><code>backend</code> – the backend (also called JuMP <code>solver</code>)</li><li><code>kwargs</code>  – additional keyword arguments</li></ul><p><strong>Output</strong></p><p>An instance of <code>SOSModel</code> for the given backend and options.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/RangeEnclosures.jl/blob/15bbfe9c7e0bba2161d170f1a00d06409fdedb16/src/sdp.jl#L6-L19">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../types/">« Types</a><a class="docs-footer-nextpage" href="../../about/">About »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Friday 25 March 2022 06:24">Friday 25 March 2022</span>. Using Julia version 1.6.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
